diff --git a/src/keccak_circuit.rs b/home/a/scroll/zkevm-circuits/zkevm-circuits/src/keccak_circuit.rs
index 524e8bf..93e23e2 100644
--- a/src/keccak_circuit.rs
+++ b/home/a/scroll/zkevm-circuits/zkevm-circuits/src/keccak_circuit.rs
@@ -1,100 +1,48 @@
+//! The keccak circuit implementation.
 mod cell_manager;
+/// Keccak packed multi
 pub mod keccak_packed_multi;
-mod keccak_table;
 mod param;
 mod table;
 #[cfg(test)]
 mod test;
-pub mod util;
+/// Util
+mod util;
 
-use keccak_table::KeccakTable;
 use std::marker::PhantomData;
+pub use KeccakCircuitConfig as KeccakConfig;
 
-use self::{cell_manager::*, keccak_packed_multi::*, param::*, table::*};
-use param::{
-    CHI_BASE_LOOKUP_TABLE, NUM_BYTES_PER_WORD, NUM_ROUNDS, NUM_WORDS_TO_ABSORB,
-    NUM_WORDS_TO_SQUEEZE, RHO_MATRIX,
+use self::{cell_manager::*, keccak_packed_multi::*, param::*, table::*, util::*};
+use crate::{
+    evm_circuit::util::constraint_builder::BaseConstraintBuilder,
+    table::{KeccakTable, LookupTable},
+    util::{Challenges, SubCircuit, SubCircuitConfig},
+    witness,
 };
-use util::{
-    constraint_builder::BaseConstraintBuilder,
-    eth_types::Field,
-    expression::{and, not, select, Expr},
-    get_absorb_positions, get_num_bits_per_lookup, rotate, scatter, target_part_sizes,
-};
-
-use crate::halo2_proofs::{
+use eth_types::Field;
+use gadgets::util::{and, not, select, sum, Expr};
+use halo2_proofs::{
     circuit::{Layouter, Region, Value},
-    plonk::{
-        Advice, Challenge, Column, ConstraintSystem, Error, Expression, Fixed, TableColumn,
-        VirtualCells,
-    },
+    plonk::{Column, ConstraintSystem, Error, Expression, Fixed, TableColumn, VirtualCells},
     poly::Rotation,
 };
-use halo2_base::halo2_proofs::{circuit::AssignedCell, plonk::Assigned};
-use itertools::Itertools;
 use log::info;
 
-#[cfg(feature = "halo2-axiom")]
-type KeccakAssignedValue<'v, F> = AssignedCell<&'v Assigned<F>, F>;
-#[cfg(not(feature = "halo2-axiom"))]
-type KeccakAssignedValue<'v, F> = AssignedCell<F, F>;
-
-pub fn assign_advice_custom<'v, F: Field>(
-    region: &mut Region<F>,
-    column: Column<Advice>,
-    offset: usize,
-    value: Value<F>,
-) -> KeccakAssignedValue<'v, F> {
-    #[cfg(feature = "halo2-axiom")]
-    {
-        region.assign_advice(column, offset, value)
-    }
-    #[cfg(feature = "halo2-pse")]
-    {
-        region
-            .assign_advice(|| format!("assign advice {}", offset), column, offset, || value)
-            .unwrap()
-    }
-}
-
-pub fn assign_fixed_custom<F: Field>(
-    region: &mut Region<F>,
-    column: Column<Fixed>,
-    offset: usize,
-    value: F,
-) {
-    #[cfg(feature = "halo2-axiom")]
-    {
-        region.assign_fixed(column, offset, value);
-    }
-    #[cfg(feature = "halo2-pse")]
-    {
-        region
-            .assign_fixed(
-                || format!("assign fixed {}", offset),
-                column,
-                offset,
-                || Value::known(value),
-            )
-            .unwrap();
-    }
-}
+#[cfg(any(feature = "test", test, feature = "test-circuits"))]
+use halo2_proofs::{circuit::SimpleFloorPlanner, plonk::Circuit};
 
 /// KeccakConfig
 #[derive(Clone, Debug)]
 pub struct KeccakCircuitConfig<F> {
-    challenge: Challenge,
     q_enable: Column<Fixed>,
-    // q_enable_row: Column<Fixed>,
     q_first: Column<Fixed>,
     q_round: Column<Fixed>,
     q_absorb: Column<Fixed>,
     q_round_last: Column<Fixed>,
     q_padding: Column<Fixed>,
     q_padding_last: Column<Fixed>,
-
+    /// The columns for other circuits to lookup Keccak hash results
     pub keccak_table: KeccakTable,
-
     cell_manager: CellManager<F>,
     round_cst: Column<Fixed>,
     normalize_3: [TableColumn; 2],
@@ -105,14 +53,31 @@ pub struct KeccakCircuitConfig<F> {
     _marker: PhantomData<F>,
 }
 
-impl<F: Field> KeccakCircuitConfig<F> {
-    pub fn challenge(&self) -> Challenge {
-        self.challenge
-    }
+/// Circuit configuration arguments
+pub struct KeccakCircuitConfigArgs<F: Field> {
+    /// KeccakTable
+    pub keccak_table: KeccakTable,
+    /// Challenges randomness
+    pub challenges: Challenges<Expression<F>>,
+}
+
+impl<F: Field> SubCircuitConfig<F> for KeccakCircuitConfig<F> {
+    type ConfigArgs = KeccakCircuitConfigArgs<F>;
+
     /// Return a new KeccakCircuitConfig
-    pub fn new(meta: &mut ConstraintSystem<F>, challenge: Challenge) -> Self {
+    fn new(
+        meta: &mut ConstraintSystem<F>,
+        Self::ConfigArgs {
+            keccak_table,
+            challenges,
+        }: Self::ConfigArgs,
+    ) -> Self {
+        assert!(
+            get_num_rows_per_round() > NUM_BYTES_PER_WORD,
+            "KeccakCircuit requires KECCAK_ROWS>=9"
+        );
+
         let q_enable = meta.fixed_column();
-        // let q_enable_row = meta.fixed_column();
         let q_first = meta.fixed_column();
         let q_round = meta.fixed_column();
         let q_absorb = meta.fixed_column();
@@ -120,10 +85,9 @@ impl<F: Field> KeccakCircuitConfig<F> {
         let q_padding = meta.fixed_column();
         let q_padding_last = meta.fixed_column();
         let round_cst = meta.fixed_column();
-        let keccak_table = KeccakTable::construct(meta);
 
         let is_final = keccak_table.is_enabled;
-        // let length = keccak_table.input_len;
+        let length = keccak_table.input_len;
         let data_rlc = keccak_table.input_rlc;
         let hash_rlc = keccak_table.output_rlc;
 
@@ -133,7 +97,6 @@ impl<F: Field> KeccakCircuitConfig<F> {
         let chi_base_table = array_init::array_init(|_| meta.lookup_table_column());
         let pack_table = array_init::array_init(|_| meta.lookup_table_column());
 
-        let num_rows_per_round = get_num_rows_per_round();
         let mut cell_manager = CellManager::new(get_num_rows_per_round());
         let mut cb = BaseConstraintBuilder::new(MAX_DEGREE);
         let mut total_lookup_counter = 0;
@@ -156,7 +119,7 @@ impl<F: Field> KeccakCircuitConfig<F> {
             for j in 0..5 {
                 let cell = cell_manager.query_cell(meta);
                 s[i][j] = cell.expr();
-                s_next[i][j] = cell.at_offset(meta, num_rows_per_round as i32).expr();
+                s_next[i][j] = cell.at_offset(meta, get_num_rows_per_round() as i32).expr();
             }
         }
         // Absorb data
@@ -167,7 +130,7 @@ impl<F: Field> KeccakCircuitConfig<F> {
         let mut absorb_data_next = vec![0u64.expr(); NUM_WORDS_TO_ABSORB];
         let mut absorb_result_next = vec![0u64.expr(); NUM_WORDS_TO_ABSORB];
         for i in 0..NUM_WORDS_TO_ABSORB {
-            let rot = ((i + 1) * num_rows_per_round) as i32;
+            let rot = ((i + 1) * get_num_rows_per_round()) as i32;
             absorb_from_next[i] = absorb_from.at_offset(meta, rot).expr();
             absorb_data_next[i] = absorb_data.at_offset(meta, rot).expr();
             absorb_result_next[i] = absorb_result.at_offset(meta, rot).expr();
@@ -187,8 +150,7 @@ impl<F: Field> KeccakCircuitConfig<F> {
         let mut lookup_counter = 0;
         let part_size = get_num_bits_per_absorb_lookup();
         let input = absorb_from.expr() + absorb_data.expr();
-        let absorb_fat =
-            split::expr(meta, &mut cell_manager, &mut cb, input, 0, part_size, false, None);
+        let absorb_fat = split::expr(meta, &mut cell_manager, &mut cb, input, 0, part_size);
         cell_manager.start_region();
         let absorb_res = transform::expr(
             "absorb",
@@ -199,37 +161,52 @@ impl<F: Field> KeccakCircuitConfig<F> {
             normalize_3,
             true,
         );
-        cb.require_equal("absorb result", decode::expr(absorb_res), absorb_result.expr());
+        cb.require_equal(
+            "absorb result",
+            decode::expr(absorb_res),
+            absorb_result.expr(),
+        );
         info!("- Post absorb:");
         info!("Lookups: {}", lookup_counter);
         info!("Columns: {}", cell_manager.get_width());
         total_lookup_counter += lookup_counter;
 
-        // Squeeze
-        // The squeezing happening at the end of the 24 rounds is done spread out
-        // over those 24 rounds. In a single round (in 4 of the 24 rounds) a
-        // single word is converted to bytes.
+        // Process inputs.
+        // "Absorb" happens at the first round. However, the input is witnessed and processed
+        // over the first 17 rounds. Each round converts a word into 8 bytes.
         cell_manager.start_region();
         let mut lookup_counter = 0;
         // Potential optimization: could do multiple bytes per lookup
-        let packed_parts =
-            split::expr(meta, &mut cell_manager, &mut cb, absorb_data.expr(), 0, 8, false, None);
+        let packed_parts = split::expr(
+            meta,
+            &mut cell_manager,
+            &mut cb,
+            absorb_data.expr(),
+            0,
+            NUM_BYTES_PER_WORD,
+        );
         cell_manager.start_region();
-        // input_bytes.len() = packed_parts.len() = 64 / 8 = 8 = NUM_BYTES_PER_WORD
         let input_bytes = transform::expr(
-            "squeeze unpack",
+            "input unpack",
             meta,
             &mut cell_manager,
             &mut lookup_counter,
             packed_parts,
-            pack_table.into_iter().rev().collect::<Vec<_>>().try_into().unwrap(),
+            pack_table
+                .into_iter()
+                .rev()
+                .collect::<Vec<_>>()
+                .try_into()
+                .unwrap(),
             true,
         );
-        debug_assert_eq!(input_bytes.len(), NUM_BYTES_PER_WORD);
 
         // Padding data
         cell_manager.start_region();
-        let is_paddings = input_bytes.iter().map(|_| cell_manager.query_cell(meta)).collect_vec();
+        let mut is_paddings = Vec::new();
+        for _ in input_bytes.iter() {
+            is_paddings.push(cell_manager.query_cell(meta));
+        }
         info!("- Post padding:");
         info!("Lookups: {}", lookup_counter);
         info!("Columns: {}", cell_manager.get_width());
@@ -256,8 +233,6 @@ impl<F: Field> KeccakCircuitConfig<F> {
                 c,
                 1,
                 part_size_c,
-                false,
-                None,
             ));
         }
         // Now calculate `bc` by normalizing `c`
@@ -334,7 +309,7 @@ impl<F: Field> KeccakCircuitConfig<F> {
                     if row_idx == 0 {
                         num_columns += 1;
                     }
-                    row_idx = (((row_idx as usize) + 1) % num_rows_per_round) as i32;
+                    row_idx = (((row_idx as usize) + 1) % get_num_rows_per_round()) as i32;
                 }
             }
         }
@@ -352,7 +327,6 @@ impl<F: Field> KeccakCircuitConfig<F> {
                     s[i][j].clone(),
                     RHO_MATRIX[i][j],
                     part_size,
-                    true,
                 );
                 // Normalize the data to the target cells
                 let s_parts = transform_to::expr(
@@ -395,8 +369,12 @@ impl<F: Field> KeccakCircuitConfig<F> {
             let mut input: [Expression<F>; 5] = array_init::array_init(|_| 0.expr());
             let mut output: [Expression<F>; 5] = array_init::array_init(|_| 0.expr());
             for c in 0..5 {
-                input[c] = cell_manager.columns()[column_starts[1] + idx * 5 + c].expr.clone();
-                output[c] = cell_manager.columns()[column_starts[2] + idx * 5 + c].expr.clone();
+                input[c] = cell_manager.columns()[column_starts[1] + idx * 5 + c]
+                    .expr
+                    .clone();
+                output[c] = cell_manager.columns()[column_starts[2] + idx * 5 + c]
+                    .expr
+                    .clone();
             }
             // Now calculate `a ^ ((~b) & c)` by doing `lookup[3 - 2*a + b - c]`
             for i in 0..5 {
@@ -405,7 +383,10 @@ impl<F: Field> KeccakCircuitConfig<F> {
                     - input[(i + 2) % 5].clone().clone();
                 let output = output[i].clone();
                 meta.lookup("chi base", |_| {
-                    vec![(input.clone(), chi_base_table[0]), (output.clone(), chi_base_table[1])]
+                    vec![
+                        (input.clone(), chi_base_table[0]),
+                        (output.clone(), chi_base_table[1]),
+                    ]
                 });
                 lookup_counter += 1;
             }
@@ -433,8 +414,7 @@ impl<F: Field> KeccakCircuitConfig<F> {
         cell_manager.start_region();
         let part_size = get_num_bits_per_absorb_lookup();
         let input = s[0][0].clone() + round_cst_expr.clone();
-        let iota_parts =
-            split::expr(meta, &mut cell_manager, &mut cb, input, 0, part_size, false, None);
+        let iota_parts = split::expr(meta, &mut cell_manager, &mut cb, input, 0, part_size);
         cell_manager.start_region();
         // Could share columns with absorb which may end up using 1 lookup/column
         // fewer...
@@ -465,7 +445,7 @@ impl<F: Field> KeccakCircuitConfig<F> {
         let squeeze_from = cell_manager.query_cell(meta);
         let mut squeeze_from_prev = vec![0u64.expr(); NUM_WORDS_TO_SQUEEZE];
         for (idx, squeeze_from_prev) in squeeze_from_prev.iter_mut().enumerate() {
-            let rot = (-(idx as i32) - 1) * num_rows_per_round as i32;
+            let rot = (-(idx as i32) - 1) * get_num_rows_per_round() as i32;
             *squeeze_from_prev = squeeze_from.at_offset(meta, rot).expr();
         }
         // Squeeze
@@ -477,7 +457,7 @@ impl<F: Field> KeccakCircuitConfig<F> {
         // Unpack a single word into bytes (for the squeeze)
         // Potential optimization: could do multiple bytes per lookup
         let squeeze_from_parts =
-            split::expr(meta, &mut cell_manager, &mut cb, squeeze_from.expr(), 0, 8, false, None);
+            split::expr(meta, &mut cell_manager, &mut cb, squeeze_from.expr(), 0, 8);
         cell_manager.start_region();
         let squeeze_bytes = transform::expr(
             "squeeze unpack",
@@ -485,7 +465,12 @@ impl<F: Field> KeccakCircuitConfig<F> {
             &mut cell_manager,
             &mut lookup_counter,
             squeeze_from_parts,
-            pack_table.into_iter().rev().collect::<Vec<_>>().try_into().unwrap(),
+            pack_table
+                .into_iter()
+                .rev()
+                .collect::<Vec<_>>()
+                .try_into()
+                .unwrap(),
             true,
         );
         info!("- Post squeeze:");
@@ -494,7 +479,9 @@ impl<F: Field> KeccakCircuitConfig<F> {
         total_lookup_counter += lookup_counter;
 
         // The round constraints that we've been building up till now
-        meta.create_gate("round", |meta| cb.gate(meta.query_fixed(q_round, Rotation::cur())));
+        meta.create_gate("round", |meta| {
+            cb.gate(meta.query_fixed(q_round, Rotation::cur()))
+        });
 
         // Absorb
         meta.create_gate("absorb", |meta| {
@@ -538,7 +525,7 @@ impl<F: Field> KeccakCircuitConfig<F> {
         let mut hash_bytes = Vec::new();
         for i in 0..NUM_WORDS_TO_SQUEEZE {
             for byte in squeeze_bytes.iter() {
-                let rot = (-(i as i32) - 1) * num_rows_per_round as i32;
+                let rot = (-(i as i32) - 1) * get_num_rows_per_round() as i32;
                 hash_bytes.push(byte.cell.at_offset(meta, rot).expr());
             }
         }
@@ -548,8 +535,12 @@ impl<F: Field> KeccakCircuitConfig<F> {
             let mut cb = BaseConstraintBuilder::new(MAX_DEGREE);
             let start_new_hash = start_new_hash(meta, Rotation::cur());
             // The words to squeeze
-            let hash_words: Vec<_> =
-                pre_s.into_iter().take(4).map(|a| a[0].clone()).take(4).collect();
+            let hash_words: Vec<_> = pre_s
+                .into_iter()
+                .take(4)
+                .map(|a| a[0].clone())
+                .take(4)
+                .collect();
             // Verify if we converted the correct words to bytes on previous rows
             for (idx, word) in hash_words.iter().enumerate() {
                 cb.condition(start_new_hash.clone(), |cb| {
@@ -560,18 +551,25 @@ impl<F: Field> KeccakCircuitConfig<F> {
                     );
                 });
             }
-
-            let challenge_expr = meta.query_challenge(challenge);
-            let rlc =
-                hash_bytes.into_iter().reduce(|rlc, x| rlc * challenge_expr.clone() + x).unwrap();
-            cb.require_equal("hash rlc check", rlc, meta.query_advice(hash_rlc, Rotation::cur()));
+            let hash_bytes_le = hash_bytes.into_iter().rev().collect::<Vec<_>>();
+            let rlc = compose_rlc::expr(&hash_bytes_le, challenges.evm_word());
+            cb.condition(start_new_hash, |cb| {
+                cb.require_equal(
+                    "hash rlc check",
+                    rlc,
+                    meta.query_advice(hash_rlc, Rotation::cur()),
+                );
+            });
             cb.gate(meta.query_fixed(q_round_last, Rotation::cur()))
         });
 
         // Some general input checks
         meta.create_gate("input checks", |meta| {
             let mut cb = BaseConstraintBuilder::new(MAX_DEGREE);
-            cb.require_boolean("boolean is_final", meta.query_advice(is_final, Rotation::cur()));
+            cb.require_boolean(
+                "boolean is_final",
+                meta.query_advice(is_final, Rotation::cur()),
+            );
             cb.gate(meta.query_fixed(q_enable, Rotation::cur()))
         });
 
@@ -588,7 +586,7 @@ impl<F: Field> KeccakCircuitConfig<F> {
         // Enforce logic for when this block is the last block for a hash
         let last_is_padding_in_block = is_paddings.last().unwrap().at_offset(
             meta,
-            -(((NUM_ROUNDS + 1 - NUM_WORDS_TO_ABSORB) * num_rows_per_round) as i32),
+            -(((NUM_ROUNDS + 1 - NUM_WORDS_TO_ABSORB) * get_num_rows_per_round()) as i32),
         );
         meta.create_gate("is final", |meta| {
             let mut cb = BaseConstraintBuilder::new(MAX_DEGREE);
@@ -606,7 +604,7 @@ impl<F: Field> KeccakCircuitConfig<F> {
             );
             // For all the rows of a round, only the first row can have `is_final == 1`.
             cb.condition(
-                (1..num_rows_per_round as i32)
+                (1..get_num_rows_per_round() as i32)
                     .map(|i| meta.query_fixed(q_enable, Rotation(-i)))
                     .fold(0.expr(), |acc, elem| acc + elem),
                 |cb| {
@@ -622,8 +620,10 @@ impl<F: Field> KeccakCircuitConfig<F> {
         // Padding
         // May be cleaner to do this padding logic in the byte conversion lookup but
         // currently easier to do it like this.
-        let prev_is_padding =
-            is_paddings.last().unwrap().at_offset(meta, -(num_rows_per_round as i32));
+        let prev_is_padding = is_paddings
+            .last()
+            .unwrap()
+            .at_offset(meta, -(get_num_rows_per_round() as i32));
         meta.create_gate("padding", |meta| {
             let mut cb = BaseConstraintBuilder::new(MAX_DEGREE);
             let q_padding = meta.query_fixed(q_padding, Rotation::cur());
@@ -646,8 +646,11 @@ impl<F: Field> KeccakCircuitConfig<F> {
             // Now for each padding selector
             for idx in 0..is_paddings.len() {
                 // Previous padding selector can be on the previous row
-                let is_padding_prev =
-                    if idx == 0 { prev_is_padding.expr() } else { is_paddings[idx - 1].expr() };
+                let is_padding_prev = if idx == 0 {
+                    prev_is_padding.expr()
+                } else {
+                    is_paddings[idx - 1].expr()
+                };
                 let is_first_padding = is_paddings[idx].expr() - is_padding_prev.clone();
 
                 // Check padding transition 0 -> 1 done only once
@@ -689,61 +692,84 @@ impl<F: Field> KeccakCircuitConfig<F> {
                     );
                 } else {
                     // Padding start/intermediate byte
-                    cb.condition(and::expr([q_padding.expr(), is_paddings[idx].expr()]), |cb| {
-                        // Input bytes need to be zero, or one if this is the first padding byte
-                        cb.require_equal(
-                            "padding start/intermediate byte",
-                            input_bytes[idx].expr.clone(),
-                            is_first_padding.expr(),
-                        );
-                    });
+                    cb.condition(
+                        and::expr([q_padding.expr(), is_paddings[idx].expr()]),
+                        |cb| {
+                            // Input bytes need to be zero, or one if this is the first padding byte
+                            cb.require_equal(
+                                "padding start/intermediate byte",
+                                input_bytes[idx].expr.clone(),
+                                is_first_padding.expr(),
+                            );
+                        },
+                    );
                 }
             }
             cb.gate(1.expr())
         });
 
-        assert!(num_rows_per_round > NUM_BYTES_PER_WORD, "We require enough rows per round to hold the running RLC of the bytes from the one keccak word absorbed per round");
-        // TODO: there is probably a way to only require NUM_BYTES_PER_WORD instead of
-        // NUM_BYTES_PER_WORD + 1 rows per round, but for simplicity and to keep the
-        // gate degree at 3, we just do the obvious thing for now Input data rlc
-        meta.create_gate("data rlc", |meta| {
+        // Length and input data rlc
+        meta.create_gate("length and data rlc", |meta| {
             let mut cb = BaseConstraintBuilder::new(MAX_DEGREE);
 
             let q_padding = meta.query_fixed(q_padding, Rotation::cur());
-            let start_new_hash_prev = start_new_hash(meta, Rotation(-(num_rows_per_round as i32)));
-            let data_rlc_prev = meta.query_advice(data_rlc, Rotation(-(num_rows_per_round as i32)));
+            let start_new_hash_prev =
+                start_new_hash(meta, Rotation(-(get_num_rows_per_round() as i32)));
+            let length_prev =
+                meta.query_advice(length, Rotation(-(get_num_rows_per_round() as i32)));
+            let length = meta.query_advice(length, Rotation::cur());
+            let data_rlc_prev =
+                meta.query_advice(data_rlc, Rotation(-(get_num_rows_per_round() as i32)));
+            let data_rlcs: Vec<_> = (0..NUM_BYTES_PER_WORD + 1)
+                .map(|i| meta.query_advice(data_rlc, Rotation(i as i32)))
+                .collect();
+            assert_eq!(data_rlcs.len(), input_bytes.len() + 1);
 
             // Update the length/data_rlc on rows where we absorb data
             cb.condition(q_padding.expr(), |cb| {
-                let challenge_expr = meta.query_challenge(challenge);
-                // Use intermediate cells to keep the degree low
-                let mut new_data_rlc =
+                // Length increases by the number of bytes that aren't padding
+                cb.require_equal(
+                    "update length",
+                    length.clone(),
+                    length_prev.clone() * not::expr(start_new_hash_prev.expr())
+                        + sum::expr(
+                            is_paddings
+                                .iter()
+                                .map(|is_padding| not::expr(is_padding.expr())),
+                        ),
+                );
+
+                let mut new_data_rlc = data_rlcs[NUM_BYTES_PER_WORD].expr();
+
+                // At the start of a hash, start at 0. Otherwise, continue from the previous value.
+                let data_rlc_zero_or_prev =
                     data_rlc_prev.clone() * not::expr(start_new_hash_prev.expr());
-                let mut data_rlcs = (0..NUM_BYTES_PER_WORD)
-                    .map(|i| meta.query_advice(data_rlc, Rotation(i as i32 + 1)));
-                let intermed_rlc = data_rlcs.next().unwrap();
-                cb.require_equal("initial data rlc", intermed_rlc.clone(), new_data_rlc);
-                new_data_rlc = intermed_rlc;
-                for (byte, is_padding) in input_bytes.iter().zip(is_paddings.iter()) {
+                cb.require_equal(
+                    "initial data rlc",
+                    data_rlc_zero_or_prev,
+                    new_data_rlc.clone(),
+                );
+
+                // Add the word `input_bytes` to `data_rlc`. It has a variable length represented by
+                // `is_paddings`, which requires intermediate cells to keep the degree low.
+                for (idx, (byte, is_padding)) in
+                    input_bytes.iter().zip(is_paddings.iter()).enumerate()
+                {
                     new_data_rlc = select::expr(
                         is_padding.expr(),
                         new_data_rlc.clone(),
-                        new_data_rlc * challenge_expr.clone() + byte.expr.clone(),
+                        new_data_rlc.clone() * challenges.keccak_input() + byte.expr.clone(),
                     );
-                    if let Some(intermed_rlc) = data_rlcs.next() {
-                        cb.require_equal(
-                            "intermediate data rlc",
-                            intermed_rlc.clone(),
-                            new_data_rlc,
-                        );
-                        new_data_rlc = intermed_rlc;
-                    }
+                    let data_rlc_after_this_byte = data_rlcs[NUM_BYTES_PER_WORD - (idx + 1)].expr();
+                    cb.require_equal(
+                        "intermediate data rlc",
+                        data_rlc_after_this_byte.clone(),
+                        new_data_rlc,
+                    );
+                    new_data_rlc = data_rlc_after_this_byte;
                 }
-                cb.require_equal(
-                    "update data rlc",
-                    meta.query_advice(data_rlc, Rotation::cur()),
-                    new_data_rlc,
-                );
+                // At this point, `data_rlcs[0]` includes the new input word. It will be copied into
+                // the next round, or it is the final `input_rlc` in the lookup table.
             });
             // Keep length/data_rlc the same on rows where we don't absorb data
             cb.condition(
@@ -753,9 +779,10 @@ impl<F: Field> KeccakCircuitConfig<F> {
                     not::expr(q_padding),
                 ]),
                 |cb| {
+                    cb.require_equal("length equality check", length.clone(), length_prev.clone());
                     cb.require_equal(
                         "data_rlc equality check",
-                        meta.query_advice(data_rlc, Rotation::cur()),
+                        data_rlcs[0].clone(),
                         data_rlc_prev.clone(),
                     );
                 },
@@ -763,29 +790,45 @@ impl<F: Field> KeccakCircuitConfig<F> {
             cb.gate(1.expr())
         });
 
+        keccak_table.annotate_columns(meta);
+
+        normalize_3.iter().enumerate().for_each(|(idx, &col)| {
+            meta.annotate_lookup_column(col, || format!("KECCAK_normalize_3_{}", idx))
+        });
+        normalize_4.iter().enumerate().for_each(|(idx, &col)| {
+            meta.annotate_lookup_column(col, || format!("KECCAK_normalize_4_{}", idx))
+        });
+        normalize_6.iter().enumerate().for_each(|(idx, &col)| {
+            meta.annotate_lookup_column(col, || format!("KECCAK_normalize_6_{}", idx))
+        });
+        chi_base_table.iter().enumerate().for_each(|(idx, &col)| {
+            meta.annotate_lookup_column(col, || format!("KECCAK_chi_base_{}", idx))
+        });
+        pack_table.iter().enumerate().for_each(|(idx, &col)| {
+            meta.annotate_lookup_column(col, || format!("KECCAK_pack_table_{}", idx))
+        });
+
         info!("Degree: {}", meta.degree());
         info!("Minimum rows: {}", meta.minimum_rows());
         info!("Total Lookups: {}", total_lookup_counter);
-        #[cfg(feature = "display")]
-        {
-            println!("Total Keccak Columns: {}", cell_manager.get_width());
-            std::env::set_var("KECCAK_ADVICE_COLUMNS", cell_manager.get_width().to_string());
-        }
-        #[cfg(not(feature = "display"))]
-        info!("Total Keccak Columns: {}", cell_manager.get_width());
+        info!("Total Columns: {}", cell_manager.get_width());
         info!("num unused cells: {}", cell_manager.get_num_unused_cells());
         info!("part_size absorb: {}", get_num_bits_per_absorb_lookup());
         info!("part_size theta: {}", get_num_bits_per_theta_c_lookup());
-        info!("part_size theta c: {}", get_num_bits_per_lookup(THETA_C_LOOKUP_RANGE));
+        info!(
+            "part_size theta c: {}",
+            get_num_bits_per_lookup(THETA_C_LOOKUP_RANGE)
+        );
         info!("part_size theta t: {}", get_num_bits_per_lookup(4));
         info!("part_size rho/pi: {}", get_num_bits_per_rho_pi_lookup());
         info!("part_size chi base: {}", get_num_bits_per_base_chi_lookup());
-        info!("uniform part sizes: {:?}", target_part_sizes(get_num_bits_per_theta_c_lookup()));
+        info!(
+            "uniform part sizes: {:?}",
+            target_part_sizes(get_num_bits_per_theta_c_lookup())
+        );
 
         KeccakCircuitConfig {
-            challenge,
             q_enable,
-            // q_enable_row,
             q_first,
             q_round,
             q_absorb,
@@ -806,43 +849,90 @@ impl<F: Field> KeccakCircuitConfig<F> {
 }
 
 impl<F: Field> KeccakCircuitConfig<F> {
-    pub fn assign(&self, region: &mut Region<'_, F>, witness: &[KeccakRow<F>]) {
-        for (offset, keccak_row) in witness.iter().enumerate() {
-            self.set_row(region, offset, keccak_row);
-        }
+    pub(crate) fn assign(
+        &self,
+        layouter: &mut impl Layouter<F>,
+        witness: &[KeccakRow<F>],
+    ) -> Result<(), Error> {
+        layouter.assign_region(
+            || "assign keccak rows",
+            |mut region| {
+                for (offset, keccak_row) in witness.iter().enumerate() {
+                    self.set_row(&mut region, offset, keccak_row)?;
+                }
+                self.keccak_table.annotate_columns_in_region(&mut region);
+                self.annotate_circuit(&mut region);
+                Ok(())
+            },
+        )
     }
 
-    pub fn set_row(&self, region: &mut Region<'_, F>, offset: usize, row: &KeccakRow<F>) {
+    fn set_row(
+        &self,
+        region: &mut Region<'_, F>,
+        offset: usize,
+        row: &KeccakRow<F>,
+    ) -> Result<(), Error> {
         // Fixed selectors
-        for (_, column, value) in &[
+        for (name, column, value) in &[
             ("q_enable", self.q_enable, F::from(row.q_enable)),
             ("q_first", self.q_first, F::from(offset == 0)),
             ("q_round", self.q_round, F::from(row.q_round)),
             ("q_round_last", self.q_round_last, F::from(row.q_round_last)),
             ("q_absorb", self.q_absorb, F::from(row.q_absorb)),
             ("q_padding", self.q_padding, F::from(row.q_padding)),
-            ("q_padding_last", self.q_padding_last, F::from(row.q_padding_last)),
+            (
+                "q_padding_last",
+                self.q_padding_last,
+                F::from(row.q_padding_last),
+            ),
         ] {
-            assign_fixed_custom(region, *column, offset, *value);
+            region.assign_fixed(
+                || format!("assign {} {}", name, offset),
+                *column,
+                offset,
+                || Value::known(*value),
+            )?;
         }
 
-        assign_advice_custom(
+        self.keccak_table.assign_row(
             region,
-            self.keccak_table.is_enabled,
             offset,
-            Value::known(F::from(row.is_final)),
-        );
+            [
+                Value::known(F::from(row.is_final)),
+                row.data_rlc,
+                Value::known(F::from(row.length as u64)),
+                row.hash_rlc,
+            ],
+        )?;
 
         // Cell values
-        row.cell_values.iter().zip(self.cell_manager.columns()).for_each(|(bit, column)| {
-            assign_advice_custom(region, column.advice, offset, Value::known(*bit));
-        });
+        for (idx, (bit, column)) in row
+            .cell_values
+            .iter()
+            .zip(self.cell_manager.columns())
+            .enumerate()
+        {
+            region.assign_advice(
+                || format!("assign lookup value {} {}", idx, offset),
+                column.advice,
+                offset,
+                || Value::known(*bit),
+            )?;
+        }
 
         // Round constant
-        assign_fixed_custom(region, self.round_cst, offset, row.round_cst);
+        region.assign_fixed(
+            || format!("assign round cst {}", offset),
+            self.round_cst,
+            offset,
+            || Value::known(row.round_cst),
+        )?;
+
+        Ok(())
     }
 
-    pub fn load_aux_tables(&self, layouter: &mut impl Layouter<F>) -> Result<(), Error> {
+    pub(crate) fn load_aux_tables(&self, layouter: &mut impl Layouter<F>) -> Result<(), Error> {
         load_normalize_table(layouter, "normalize_6", &self.normalize_6, 6u64)?;
         load_normalize_table(layouter, "normalize_4", &self.normalize_4, 4u64)?;
         load_normalize_table(layouter, "normalize_3", &self.normalize_3, 3u64)?;
@@ -855,4 +945,123 @@ impl<F: Field> KeccakCircuitConfig<F> {
         )?;
         load_pack_table(layouter, &self.pack_table)
     }
+
+    fn annotate_circuit(&self, region: &mut Region<F>) {
+        region.name_column(|| "KECCAK_q_enable", self.q_enable);
+        region.name_column(|| "KECCAK_q_first", self.q_first);
+        region.name_column(|| "KECCAK_q_round", self.q_round);
+        region.name_column(|| "KECCAK_q_absorb", self.q_absorb);
+        region.name_column(|| "KECCAK_q_round_last", self.q_round_last);
+        region.name_column(|| "KECCAK_q_padding_last", self.q_padding_last);
+    }
+}
+
+/// KeccakCircuit
+#[derive(Default, Clone, Debug)]
+pub struct KeccakCircuit<F: Field> {
+    inputs: Vec<Vec<u8>>,
+    num_rows: usize,
+    _marker: PhantomData<F>,
+}
+
+impl<F: Field> SubCircuit<F> for KeccakCircuit<F> {
+    type Config = KeccakCircuitConfig<F>;
+
+    /// The `block.circuits_params.keccak_padding` parmeter, when enabled, sets
+    /// up the circuit to support a fixed number of permutations/keccak_f's,
+    /// independently of the permutations required by `inputs`.
+    fn new_from_block(block: &witness::Block<F>) -> Self {
+        Self::new(
+            block.circuits_params.max_keccak_rows,
+            block.keccak_inputs.clone(),
+        )
+    }
+
+    /// Return the minimum number of rows required to prove the block
+    fn min_num_rows_block(block: &witness::Block<F>) -> (usize, usize) {
+        let rows_per_chunk = (NUM_ROUNDS + 1) * get_num_rows_per_round();
+        (
+            block
+                .keccak_inputs
+                .iter()
+                .map(|bytes| (bytes.len() as f64 / 136.0).ceil() as usize * rows_per_chunk)
+                .sum(),
+            block.circuits_params.max_keccak_rows,
+        )
+    }
+
+    /// Make the assignments to the KeccakCircuit
+    fn synthesize_sub(
+        &self,
+        config: &Self::Config,
+        challenges: &Challenges<Value<F>>,
+        layouter: &mut impl Layouter<F>,
+    ) -> Result<(), Error> {
+        config.load_aux_tables(layouter)?;
+        let witness = self.generate_witness(*challenges);
+        config.assign(layouter, witness.as_slice())
+    }
+}
+
+#[cfg(any(feature = "test", test, feature = "test-circuits"))]
+impl<F: Field> Circuit<F> for KeccakCircuit<F> {
+    type Config = (KeccakCircuitConfig<F>, Challenges);
+    type FloorPlanner = SimpleFloorPlanner;
+
+    fn without_witnesses(&self) -> Self {
+        Self::default()
+    }
+
+    fn configure(meta: &mut ConstraintSystem<F>) -> Self::Config {
+        let keccak_table = KeccakTable::construct(meta);
+        let challenges = Challenges::construct(meta);
+
+        let config = {
+            let challenges = challenges.exprs(meta);
+            KeccakCircuitConfig::new(
+                meta,
+                KeccakCircuitConfigArgs {
+                    keccak_table,
+                    challenges,
+                },
+            )
+        };
+        (config, challenges)
+    }
+
+    fn synthesize(
+        &self,
+        (config, challenges): Self::Config,
+        mut layouter: impl Layouter<F>,
+    ) -> Result<(), Error> {
+        let challenges = challenges.values(&mut layouter);
+        self.synthesize_sub(&config, &challenges, &mut layouter)
+    }
+}
+
+impl<F: Field> KeccakCircuit<F> {
+    /// Creates a new circuit instance
+    pub fn new(num_rows: usize, inputs: Vec<Vec<u8>>) -> Self {
+        KeccakCircuit {
+            inputs,
+            num_rows,
+            _marker: PhantomData,
+        }
+    }
+
+    /// The number of keccak_f's that can be done in this circuit
+    pub fn capacity(&self) -> Option<usize> {
+        if self.num_rows > 0 {
+            // Subtract two for unusable rows
+            Some(self.num_rows / ((NUM_ROUNDS + 1) * get_num_rows_per_round()) - 2)
+        } else {
+            None
+        }
+    }
+
+    /// Sets the witness using the data to be hashed
+    pub(crate) fn generate_witness(&self, challenges: Challenges<Value<F>>) -> Vec<KeccakRow<F>> {
+        multi_keccak(self.inputs.as_slice(), challenges, self.capacity())
+            .expect("Too many inputs for given capacity")
+    }
 }
